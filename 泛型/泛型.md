# 泛型

### 一、泛型概述

**1. 泛型：**是JDK 5中引用的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型，它的本质是**参数化类型**，也就是说所操作的数据类型被指定为一个参数，一提到参数，最熟悉的就是定义方法是有参数，然后掉用此方法时传递实参，那么参数化类型怎么理解呢？

顾名思义，就是**将类型由原来的具体类型参数化，然后在使用/调用时传入具体的类型**，这种参数类型可以用在类、方法和接口中，分别被成为泛型类、泛型方法、泛型接口

**2. 泛型定义格式：**

- <类型>：指定一种类型的格式，这里的类型可以看成时形参
- <类型1，类型2...>：指定多种类型的格式，多种类型之间用逗号隔开，这里的类型可以看成是形参
- 将来具体调用时候给定的类型可以看成时实参，并且实参的类型只能是引用数据类型

**3. 泛型的好处：**

- 把运行时期的问题提前到了编译期间
- 避免了强制类型转换

### 二、泛型类

**泛型类的定义格式：**

- 格式：修饰符 class 类名<数据类型>{}
- 范例：public class Student <T>{}  (此处**T**可以随便写为任意标识，常见的如**T、E、K、V**等形式的参数常用于表示泛型)

### 三、泛型方法

**泛型方法的定义格式：**

- 格式：修饰符 <数据类型> 返回值类型 方法名 (类型 变量名){}
- 范例：public <T> void show(T t){}

### 四、泛型接口

**泛型接口的定义格式：**

- 格式：修饰符 interface 接口名<数据类型> {}
- 范例：public interface Student<T>{}

### 五、类型通配符

为了表示各种泛型List的父类，可以使用类型通配符

- 类型通配符：**<?>**
- List<?>:表示元素类型未知的List，它的元素可以匹配**任何的类型**
- 这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中



如果说我们不希望List<?>时任何泛型的父类，只希望代表某一类泛型List的父类，可以使用类型通配符的上限

- 类型通配符上限：**<?extends 类型>**
- List<? extends Number>：它表示的类型是**Number或者其子类型**



除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限

- 类型通配符下限：**<? super 类型>**
- List <? super Number>：它表示的类型是**Number或者其父类型类**

### 六、可变参数

**1. 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了**

- 格式：修饰符 返回值类型 方法名 (数据类型...变量名) {}
- 范例：public static int sum (int ... a){}



**2. 可变参数注意事项**

- 这里的变量其实是一个数组
- 如果一个方法有多个参数，包含可变参数，**可变参数要安放在最后**

### 七、可变参数的使用

**1. Arrays工具类中有一个静态方法：**

- public static <T> List <T> asList(T ... a)：返回由指定数组支持的谷固定大小的列表
- 返回的集合不能做增删操作，可以做修改操作

**2. List接口中有一个静态方法：**

- public static <E> List <E> of(E ... elements)：返回包含任意数量元素的不可变列表
- 返回的集合不能做增删改操作

**3. Set接口中有一个静态方法：**

- public static <E> Set<E> of(E ... elements)：返回一个包含任意数量元素的不可变集合
- 在给元素的时候，不能给重复的元素
- 返回的集合不能做操作，没有修改的方法



